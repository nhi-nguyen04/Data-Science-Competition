---
title: "Basic Analysis"
author: "Nhi Nguyen"
date: "2025-05-10"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Load Libraries, message=FALSE, warning=FALSE}

library(readr)
library(tidyverse)
library(patchwork)
library(forcats)
library(naniar)
theme_set(theme_minimal())
```

```{r Load in Data, message=FALSE}

data_train <- read_csv("Data/training_set_features.csv")
data_train_labels <- read_csv("Data/training_set_labels.csv")
data_test <- read_csv("Data/test_set_features.csv")

```

```{r Get Overiew of Data}

head(data_train)
head(data_train_labels)
head(data_test)

str(data_train)
str(data_train_labels)
str(data_test)

summary(data_train)
summary(data_train_labels)
summary(data_test)

sum(is.na(data_train))
sum(is.na(data_train_labels))
sum(is.na(data_test))

```

```{r Check if data imputation with median/mode is appopriate}

# Perform a test for MCAR
mcar_test(data_train)

# p > 0.05 → Fail to reject the null hypothesis → Data is MCAR 
# p ≤ 0.05 → Reject the null hypothesis → Data is MAR or MNAR (follows a pattern)
# p-value here: 0.996 -> MCAR and median/mode imputation works
# To avoid data leakage: apply on training set only

```


```{r Create mode function for missing data imputation}

# Function to get the mode
# Parameter:
# x: the data, where the mode should be determined

mode <- function(x, na.rm = FALSE) {
  if(na.rm){
    x = x[!is.na(x)]
  }

  ux <- unique(x)
  return(ux[which.max(tabulate(match(x, ux)))])
}

```

```{r Functions to detect outliers}

# Function that detects "categorical" outliers based on a threshold.
# Parameters:
# df: data frame that should be analysed
# cat_threshold: the threshold, where a variable is considered to be an outlier

categorical_outliers <- function(df, cat_threshold = 0.01) {
  
  # Select all categorical columns
  cat_cols <- df[sapply(df, function(x) is.character(x))]
  
  # Compute the proportions of the values in categorical columns and compare with threshold
  # Frequencies < threshold are considered as outliers
  lapply(cat_cols, function(col) {
    freq <- prop.table(table(col))
    rare <- names(freq[freq < cat_threshold])
    list(rare_levels = rare, count = length(rare))
  })
}


# Function that detects "numerical" outliers based on an IQR multiplier.
# Parameters:
# df: data frame that should be analysed
# iqr_multiplier: the factor used to identify an outlier

numeric_outliers <- function(df, iqr_multiplier = 1.5) {
  
  # Select all numeric columns
  num_cols <- df[sapply(df, is.numeric)]
  
  # Compute the quantiles and IQR and calculate the bounds
  # Values outside of the bound are considered as outliers
  lapply(num_cols, function(col) {
    Q1 <- quantile(col, 0.25, na.rm = TRUE)
    Q3 <- quantile(col, 0.75, na.rm = TRUE)
    IQR <- Q3 - Q1
    bounds <- c(lower = Q1 - iqr_multiplier * IQR, upper = Q3 + iqr_multiplier * IQR)
    # Find indices of values that lie outside the bounds
    out_idx <- which(col < bounds["lower"] | col > bounds["upper"])
    list(outlier_count = length(out_idx), bounds = bounds)
  })
}

# Apply the functions on the data:
categorical_outliers(df = data_train, cat_threshold = 0.01)

numeric_outliers(df = data_train, iqr_multiplier = 1.5)

# Little amount of outliers
# The outliers are still important and real. so leaving them in is better than removing them.

```


```{r Combine training data with training labels and reshape the data}

# Combine Training Data with Training Labels
data_train <- data_train %>%
  full_join(data_train_labels, by = "respondent_id")


# Reshape data to long format for easier plotting
long_data <- data_train_labels %>%
  select(h1n1_vaccine,
         seasonal_vaccine) %>%
  pivot_longer(
    cols = c("h1n1_vaccine",
             "seasonal_vaccine"),
    names_to = "vaccine",
    values_to = "use")

```

```{r Analyse Correlation}

# Create a table
tab <- table("H1N1 Vaccine" = data_train$h1n1_vaccine, 
             "Seasonal Vaccine" = data_train$seasonal_vaccine)

# Normalize to proportions
prop_tab <- prop.table(tab)

# Add totals
addmargins(prop_tab)

# Correlation between the target variables
cor(as.numeric(data_train$h1n1_vaccine),
    as.numeric(data_train$seasonal_vaccine),
    method = "pearson")

# Moderate positive correlation: 0.37
# People who get h1n1 vaccine tend to get the seasonal one as well but not the other way around.
# A lot of people don't get vaccinated at all.
```

```{r Check Proportions of Vaccines}

ggplot(long_data) +
  geom_bar(aes(x = as.factor(vaccine),
               fill = as.factor(use)),
           position = "fill") +
  labs(title = "Proportion of Vaccine Usage",
       x = " ",
       y = "Proportion",
       fill = "Usage")

```



